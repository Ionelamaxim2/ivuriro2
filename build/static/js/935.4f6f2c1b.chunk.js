"use strict";(self.webpackChunkivuriro_new=self.webpackChunkivuriro_new||[]).push([[935],{5935:(e,n,o)=>{o.r(n),o.d(n,{default:()=>p});var t=o(5043),i=o(2968),r=o(3037),l=o(7474),a=o(7047),c=o(9435),u=o(579);const v="\nprecision highp float;\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  vec4 modelPosition = modelMatrix * vec4(position, 1.0);\n  vec4 viewPosition = viewMatrix * modelPosition;\n  gl_Position = projectionMatrix * viewPosition;\n}\n",s="\nprecision highp float;\nuniform vec2 resolution;\nuniform float time;\nuniform float waveSpeed;\nuniform float waveFrequency;\nuniform float waveAmplitude;\nuniform vec3 waveColor;\nuniform vec2 mousePos;\nuniform int enableMouseInteraction;\nuniform float mouseRadius;\n\nvec4 mod289(vec4 x) { return x - floor(x * (1.0/289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec2 fade(vec2 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\n\nfloat cnoise(vec2 P) {\n  vec4 Pi = floor(P.xyxy) + vec4(0.0,0.0,1.0,1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0,0.0,1.0,1.0);\n  Pi = mod289(Pi);\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n  vec4 i = permute(permute(ix) + iy);\n  vec4 gx = fract(i * (1.0/41.0)) * 2.0 - 1.0;\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n  vec2 g00 = vec2(gx.x, gy.x);\n  vec2 g10 = vec2(gx.y, gy.y);\n  vec2 g01 = vec2(gx.z, gy.z);\n  vec2 g11 = vec2(gx.w, gy.w);\n  vec4 norm = taylorInvSqrt(vec4(dot(g00,g00), dot(g01,g01), dot(g10,g10), dot(g11,g11)));\n  g00 *= norm.x; g01 *= norm.y; g10 *= norm.z; g11 *= norm.w;\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  return 2.3 * mix(n_x.x, n_x.y, fade_xy.y);\n}\n\nconst int OCTAVES = 4;\nfloat fbm(vec2 p) {\n  float value = 0.0;\n  float amp = 1.0;\n  float freq = waveFrequency;\n  for (int i = 0; i < OCTAVES; i++) {\n    value += amp * abs(cnoise(p));\n    p *= freq;\n    amp *= waveAmplitude;\n  }\n  return value;\n}\n\nfloat pattern(vec2 p) {\n  vec2 p2 = p - time * waveSpeed;\n  return fbm(p + fbm(p2)); \n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution.xy;\n  uv -= 0.5;\n  uv.x *= resolution.x / resolution.y;\n  float f = pattern(uv);\n  if (enableMouseInteraction == 1) {\n    vec2 mouseNDC = (mousePos / resolution - 0.5) * vec2(1.0, -1.0);\n    mouseNDC.x *= resolution.x / resolution.y;\n    float dist = length(uv - mouseNDC);\n    float effect = 1.0 - smoothstep(0.0, mouseRadius, dist);\n    f -= 0.5 * effect;\n  }\n  vec3 col = mix(vec3(0.0), waveColor, f);\n  gl_FragColor = vec4(col, 1.0);\n}\n";class f extends a.Mj{constructor(){const e=new Map([["colorNum",new c.nc$(4)],["pixelSize",new c.nc$(2)]]);super("RetroEffect","\nprecision highp float;\nuniform float colorNum;\nuniform float pixelSize;\nconst float bayerMatrix8x8[64] = float[64](\n  0.0/64.0, 48.0/64.0, 12.0/64.0, 60.0/64.0,  3.0/64.0, 51.0/64.0, 15.0/64.0, 63.0/64.0,\n  32.0/64.0,16.0/64.0, 44.0/64.0, 28.0/64.0, 35.0/64.0,19.0/64.0, 47.0/64.0, 31.0/64.0,\n  8.0/64.0, 56.0/64.0,  4.0/64.0, 52.0/64.0, 11.0/64.0,59.0/64.0,  7.0/64.0, 55.0/64.0,\n  40.0/64.0,24.0/64.0, 36.0/64.0, 20.0/64.0, 43.0/64.0,27.0/64.0, 39.0/64.0, 23.0/64.0,\n  2.0/64.0, 50.0/64.0, 14.0/64.0, 62.0/64.0,  1.0/64.0,49.0/64.0, 13.0/64.0, 61.0/64.0,\n  34.0/64.0,18.0/64.0, 46.0/64.0, 30.0/64.0, 33.0/64.0,17.0/64.0, 45.0/64.0, 29.0/64.0,\n  10.0/64.0,58.0/64.0,  6.0/64.0, 54.0/64.0,  9.0/64.0,57.0/64.0,  5.0/64.0, 53.0/64.0,\n  42.0/64.0,26.0/64.0, 38.0/64.0, 22.0/64.0, 41.0/64.0,25.0/64.0, 37.0/64.0, 21.0/64.0\n);\n\nvec3 dither(vec2 uv, vec3 color) {\n  vec2 scaledCoord = floor(uv * resolution / pixelSize);\n  int x = int(mod(scaledCoord.x, 8.0));\n  int y = int(mod(scaledCoord.y, 8.0));\n  float threshold = bayerMatrix8x8[y * 8 + x] - 0.25;\n  float step = 1.0 / (colorNum - 1.0);\n  color += threshold * step;\n  float bias = 0.2;\n  color = clamp(color - bias, 0.0, 1.0);\n  return floor(color * (colorNum - 1.0) + 0.5) / (colorNum - 1.0);\n}\n\nvoid mainImage(in vec4 inputColor, in vec2 uv, out vec4 outputColor) {\n  vec2 normalizedPixelSize = pixelSize / resolution;\n  vec2 uvPixel = normalizedPixelSize * floor(uv / normalizedPixelSize);\n  vec4 color = texture2D(inputBuffer, uvPixel);\n  color.rgb = dither(uv, color.rgb);\n  outputColor = color;\n}\n",{uniforms:e}),this.uniforms=e}set colorNum(e){this.uniforms.get("colorNum").value=e}get colorNum(){return this.uniforms.get("colorNum").value}set pixelSize(e){this.uniforms.get("pixelSize").value=e}get pixelSize(){return this.uniforms.get("pixelSize").value}}const m=(0,l.AR)(f),x=(0,t.forwardRef)((e,n)=>{const{colorNum:o,pixelSize:t}=e;return(0,u.jsx)(m,{ref:n,colorNum:o,pixelSize:t})});function d(e){let{waveSpeed:n,waveFrequency:o,waveAmplitude:r,waveColor:a,colorNum:f,pixelSize:m,disableAnimation:d,enableMouseInteraction:p,mouseRadius:w}=e;const g=(0,t.useRef)(null),y=(0,t.useRef)(new c.I9Y),{viewport:h,size:S,gl:z}=(0,i.C)(),P=(0,t.useRef)({time:new c.nc$(0),resolution:new c.nc$(new c.I9Y(0,0)),waveSpeed:new c.nc$(n),waveFrequency:new c.nc$(o),waveAmplitude:new c.nc$(r),waveColor:new c.nc$(new c.Q1f(...a)),mousePos:new c.nc$(new c.I9Y(0,0)),enableMouseInteraction:new c.nc$(p?1:0),mouseRadius:new c.nc$(w)});(0,t.useEffect)(()=>{const e=z.getPixelRatio(),n=Math.floor(S.width*e),o=Math.floor(S.height*e),t=P.current.resolution.value;t.x===n&&t.y===o||t.set(n,o)},[S,z]);const b=(0,t.useRef)([...a]);(0,i.D)(e=>{let{clock:t}=e;const i=P.current;d||(i.time.value=t.getElapsedTime()),i.waveSpeed.value!==n&&(i.waveSpeed.value=n),i.waveFrequency.value!==o&&(i.waveFrequency.value=o),i.waveAmplitude.value!==r&&(i.waveAmplitude.value=r),b.current.every((e,n)=>e===a[n])||(i.waveColor.value.set(...a),b.current=[...a]),i.enableMouseInteraction.value=p?1:0,i.mouseRadius.value=w,p&&i.mousePos.value.copy(y.current)});return(0,u.jsxs)(u.Fragment,{children:[(0,u.jsxs)("mesh",{ref:g,scale:[h.width,h.height,1],children:[(0,u.jsx)("planeGeometry",{args:[1,1]}),(0,u.jsx)("shaderMaterial",{vertexShader:v,fragmentShader:s,uniforms:P.current})]}),(0,u.jsx)(l.s0,{children:(0,u.jsx)(x,{colorNum:f,pixelSize:m})}),(0,u.jsxs)("mesh",{onPointerMove:e=>{if(!p)return;const n=z.domElement.getBoundingClientRect(),o=z.getPixelRatio();y.current.set((e.clientX-n.left)*o,(e.clientY-n.top)*o)},position:[0,0,.01],scale:[h.width,h.height,1],visible:!1,children:[(0,u.jsx)("planeGeometry",{args:[1,1]}),(0,u.jsx)("meshBasicMaterial",{transparent:!0,opacity:0})]})]})}function p(e){let{waveSpeed:n=.05,waveFrequency:o=3,waveAmplitude:t=.3,waveColor:i=[.5,.5,.5],colorNum:l=4,pixelSize:a=2,disableAnimation:c=!1,enableMouseInteraction:v=!0,mouseRadius:s=1}=e;return(0,u.jsx)(r.Hl,{className:"w-full h-full relative",camera:{position:[0,0,6]},dpr:window.devicePixelRatio,gl:{antialias:!0,preserveDrawingBuffer:!0},children:(0,u.jsx)(d,{waveSpeed:n,waveFrequency:o,waveAmplitude:t,waveColor:i,colorNum:l,pixelSize:a,disableAnimation:c,enableMouseInteraction:v,mouseRadius:s})})}x.displayName="RetroEffect"}}]);
//# sourceMappingURL=935.4f6f2c1b.chunk.js.map